<?php
/**
 * @file
 * Code for the MC News Feed feature.
 */

include_once 'mc_news_feed.features.inc';

function mc_news_feed_late_form_alter(&$form, &$form_state, $form_id){
  global $user;
  if(!is_ct_form($form,"news_feed")){
    return;
  }

  if($submit = &$form['buttons']['submit']){
    unset($form['#redirect']);
    $submit['#submit'][] = '_mc_news_feed_submit';
  }

  $form['title']['#access'] = false;
}

function _mc_news_feed_submit($form, &$form_state){
  if(!empty($form_state['values']['og_groups'])){
    $gid = array_shift(array_values($form_state['values']['og_groups']));

    if($gid){
      $form_state['redirect'] = "node/$gid/news";
    }else{
      $form_state['redirect'] = "news";
    }
  }
}


function mc_news_feed_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
    if($node->type == 'news_feed'){
      switch($op){
        case 'validate':
          if(isset($node->feeds['FeedsHTTPFetcher']['source']) && !empty($node->feeds['FeedsHTTPFetcher']['source'])){
            $node->title = "News feed from " . $node->feeds['FeedsHTTPFetcher']['source'];
          }
        break;
      }
    }
}

function mc_news_feed_feeds_parser_sources_alter(&$sources, $content_type) {
  $sources['feed_images'] = array(
    'name' => t('Images in element'),
    'description' => t('Images occurring in the enclosures & description field'),
    'callback' => '_elementfeed_images',
  );
}

//return unique enclosures
function enclosures_get_unique($enclosures){
  //find unique enslosures
  $unique_enclosures = array();
  foreach ($enclosures as $enclosure) {
    $url = strtolower($enclosure->getValue());
    if(!isset($unique_enclosures[$url])){
      $unique_enclosures[$url] = $enclosure;
    }
  }

  return $unique_enclosures;
}

//return only image enclosures based on the mime type OR extensions
function enclosures_get_imgs($enclosures){
  //store enclosures as unique values
  $img_enclosures = array();
  $img_exts = array('png','jpg','gif','jpeg');

  $enclosure = enclosures_get_unique($enclosures);

  //check if any of them has image as mime type or ext
  foreach($enclosures as $enclosure){
    $path = pathinfo($enclosure->getValue());
    $ext = strtolower($path['extension']);
    if(startsWith(strtolower($enclosure->getMIMEType()),"image") OR in_array($ext,$img_exts)){
      $img_enclosures[] = $enclosure;
    };
  }

  return $img_enclosures;
}

function image_enclosure_from_url($url){
  $path = pathinfo($url);
  $mime = !empty($path['extension']) ? "image/".$path['extension'] : "image";
  return new FeedsEnclosure($url, $mime);
}

//return image enclosures from based on
function enclosures_html_img($html,$url = ''){
  $enclosures = array();

  if(!empty($html)){
    foreach(htmlqp($html,'img')->get() as $img){
      $src = qp($img)->attr("src");
      if(!empty($src)){
        $enclosures[] = image_enclosure_from_url($src);
      }
    }
  }

  //no images were found at the body of the image
  if(!empty($url)){
    //check the actual page for images
    $qb = htmlqp($url);

    //check if image
    $ogimage = $qb->find("meta[property='og:image']")->attr("content");
    if(!empty($ogimage)){
      $enclosures[] = image_enclosure_from_url($ogimage);
    }
  }

  //@todo improve image detection and size
  if(!empty($enclosures)){
    $unique_enclosures = enclosures_get_unique($enclosures);
    foreach($unique_enclosures as $file){
      //$imgurl = $file->getValue();
      //$file = $file->getFile();
      //$img_info = image_get_info($file);
    }
  }

  return enclosures_get_unique($enclosures);;
}

function _elementfeed_images(FeedsImportBatch $batch, $key) {
  $item = $batch->currentItem();
  $enclosures = $item['enclosures'];
  $desc = $item['description'];
  $enclosures = enclosures_get_imgs($enclosures);

  //if empty enclosures, no images found, find more images through other ways
  if(empty($enclosures)){
    $enclosures = enclosures_html_img($desc,$item['url']);
  }
  
  return array(array_shift($enclosures));
}


function mc_news_feed_feeds_node_processor_targets_alter(&$targets, $content_type) {
  $targets['enclosure_images'] = array(
    'name' => t('Enclosed Images'),
    'description' => t('Import images to MC images field'),
    'callback' => '_mc_filefield_feeds_set_target',
    'real_target' => 'field_list_image'
  );
}

function _mc_filefield_feeds_set_target($node, $field_name, $value) {
  $field_name = "field_list_image";
  // Normalize $value, create an array of FeedsEnclosures of it.
  $enclosures = array();
  if (!is_array($value)) {
    $value = array($value);
  }
  foreach ($value as $k => $v) {
    if ($v instanceof FeedsEnclosure) {
      $enclosures[] = $v;
    }
    elseif (valid_url($v)) {
      $enclosures[$k] = new FeedsEnclosure($v, 'application/octet-stream');
    }
  }

  // Map enclosures.
  $items = isset($node->$field_name) ? $node->$field_name : array();

  //dsm($enclosures);

  //store enlosures as unique values
  $unique_enclosures = array();
  foreach ($enclosures as $enclosure) {
    if(!isset($unique_enclosures[$enclosure->getValue()])){
      $unique_enclosures[$enclosure->getValue()] = $enclosure;
    }
  }

  foreach ($unique_enclosures as $enclosure) {
    if ($file = $enclosure->getFile()) {
      $field = content_fields($field_name, $node->type);
      $target_dir = filefield_widget_file_path($field, user_load($node->uid));
      $info = field_file_save_file($enclosure->getFile(), array(), $target_dir);
      if ($info) {
        $info['list'] = array();
        $info['data'] = array('description' => '');
        if ($field['list_field']) {
          $info['list'] = $field['list_default'];
        }
        $items[] = $info;
        $error = FALSE;
      }
    }
  }
  $node->$field_name = $items;
}